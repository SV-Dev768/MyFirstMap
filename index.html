<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Create a rotating globe</title>
        <meta
            name="viewport"
            content="initial-scale=1,maximum-scale=1,user-scalable=no"
        />
        <link
            href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css"
            rel="stylesheet"
        />
        <script
            src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js"
            type="text/javascript"
        ></script>
        <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
        <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
            }

            #map {
                height: 100%;
                width: 100%;
                flex-grow: 1;
            }

            #container {
                display: flex;
                height: 100%;
            }

            #sidebar {
                width: 300px;
                flex-shrink: 0;
                height: 100%;
                padding: 30px;
            }

            #btn-spin {
                font: bold 12px/20px 'Helvetica Neue', Arial, Helvetica,
                    sans-serif;
                background-color: #3386c0;
                color: #fff;
                bottom: 10px;
                left: 25%;
                z-index: 1;
                border: none;
                width: 200px;
                margin-left: -100px;
                display: block;
                cursor: pointer;
                padding: 10px 20px;
                border-radius: 3px;
                position: absolute;
            }
            #btn-spin:hover {
                background-color: #4ea0da;
            }

            button[id^='btn'] {
                font: bold 12px/20px 'Helvetica Neue', Arial, Helvetica,
                    sans-serif;
                background-color: #3386c0;
            }

            #output {
                width: 200px;
                height: 100px;
                background-color: lightgray;
                padding: 10px;
                margin: 20px;
                border: 1px solid gray;
                text-align: center;
            }

            .distance-container {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1;
            }

            .distance-container > * {
                background-color: rgba(0, 0, 0, 0.5);
                color: #fff;
                font-size: 11px;
                line-height: 18px;
                display: block;
                margin: 0;
                padding: 5px 10px;
                border-radius: 3px;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <div id="sidebar">
                <button id="btn-church">Center on Church</button>
                <button id="btn-run">Center on Run-Route</button>
                <button id="btn-school">Center on School</button>
                <button id="btn-ruler-on">Ruler On</button>
                <button id="btn-ruler-off">Ruler Off</button>
                <button id="btn-spin">Pause rotation</button>
                <div id="output"></div>
            </div>
            <div id="map"></div>
            <div id="distance" class="distance-container"></div>
        </div>

        <script>
            mapboxgl.accessToken =
                'pk.eyJ1IjoibG92ZWRvY3RvcjM2OSIsImEiOiJjbHI1eDBhamkwM2NpMnFvczd2ODIyN2QzIn0.IJsSWOjDJyqyv2McyXizag';
            // instantiates a new map
            const map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/light-v11',
                projection: 'globe', // Display the map as a globe, since satellite-v9 defaults to Mercator
                zoom: 17,
                center: [-118.148451, 34.066285], // longitute, latitude
                antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
            });

            // eslint-disable-next-line no-undef
            const tb = (window.tb = new Threebox(
                map,
                map.getCanvas().getContext('webgl'),
                {
                    defaultLights: true
                }
            ));

            // create the popup
            const popup = new mapboxgl.Popup({ offset: 25 }).setText(
                'Local 7/11.'
            );

            // Create a default Marker and add it to the map.
            new mapboxgl.Marker({
                color: '#ff0000'
            })
                .setLngLat([-118.149148, 34.068001])
                .setPopup(popup) // sets a popup on this marke
                .addTo(map);

            // global variables
            let ruler = false;

            const distanceContainer = document.getElementById('distance');

            // GeoJSON object to hold our measurement features
            const geojson = {
                type: 'FeatureCollection',
                features: []
            };

            // Used to draw a line between points
            const linestring = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: []
                }
            };

            map.on('style.load', () => {
                // map.setFog({}); // Set the default atmosphere style

                // add a source and layers for run route
                map.addSource('alhambra', {
                    type: 'geojson',
                    data: 'data/alhambra.geojson'
                });

                // add a mapbox style layer
                map.addLayer({
                    id: 'alhambra-lines',
                    type: 'line',
                    source: 'alhambra',
                    paint: {
                        'line-color': [
                            'match',
                            ['get', 'name'],
                            'run-route',
                            '#0000ff',
                            'church',
                            '#00ff00',
                            '#ffff00'
                        ],
                        'line-width': [
                            'match',
                            ['get', 'name'],
                            'run-route',
                            4,
                            'church',
                            4,
                            4
                        ]
                    },
                    filter: ['in', 'name', 'run-route', 'church']
                });

                map.addLayer({
                    id: 'alhambra-fills',
                    type: 'fill',
                    source: 'alhambra',
                    paint: {
                        'fill-color': [
                            'match',
                            ['get', 'name'],
                            'school',
                            '#ff00ff',
                            'run-route',
                            '#ff0000',
                            'church',
                            '#ff0000',
                            '#ffff00'
                        ],
                        'fill-opacity': [
                            'match',
                            ['get', 'name'],
                            'church',
                            0,
                            'run-route',
                            0,
                            0.5
                        ]
                    }
                });

                map.addLayer({
                    id: 'custom-threebox-model',
                    type: 'custom',
                    renderingMode: '3d',
                    onAdd: function () {
                        // Creative Commons License attribution:  Metlife Building model by https://sketchfab.com/NanoRay
                        // https://sketchfab.com/3d-models/metlife-building-32d3a4a1810a4d64abb9547bb661f7f3
                        const scale = 3.2;
                        const options = {
                            obj: './drone/scene.gltf',
                            type: 'gltf',
                            scale: { x: scale, y: scale, z: 2.7 },
                            units: 'meters',
                            rotation: { x: 90, y: -90, z: 0 }
                        };

                        tb.loadObj(options, (model) => {
                            model.setCoords([-118.148451, 34.066285]);
                            model.setRotation({ x: 0, y: 0, z: 241 });
                            tb.add(model);
                        });
                    },

                    render: function () {
                        tb.update();
                    }
                });

                map.addSource('geojson', {
                    type: 'geojson',
                    data: geojson
                });

                // Add styles to the map
                map.addLayer({
                    id: 'measure-points',
                    type: 'circle',
                    source: 'geojson',
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#000'
                    },
                    filter: ['in', '$type', 'Point']
                });
                map.addLayer({
                    id: 'measure-lines',
                    type: 'line',
                    source: 'geojson',
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    },
                    paint: {
                        'line-color': '#000',
                        'line-width': 2.5
                    },
                    filter: ['in', '$type', 'LineString']
                });

                map.on('click', (e) => {
                    if (ruler) {
                        const features = map.queryRenderedFeatures(e.point, {
                            layers: ['measure-points']
                        });

                        // Remove the linestring from the group
                        // so we can redraw it based on the points collection.
                        if (geojson.features.length > 1) geojson.features.pop();

                        // Clear the distance container to populate it with a new value.
                        distanceContainer.innerHTML = '';

                        // If a feature was clicked, remove it from the map.
                        if (features.length) {
                            const id = features[0].properties.id;
                            geojson.features = geojson.features.filter(
                                (point) => point.properties.id !== id
                            );
                        } else {
                            const point = {
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [e.lngLat.lng, e.lngLat.lat]
                                },
                                properties: {
                                    id: String(new Date().getTime())
                                }
                            };

                            geojson.features.push(point);
                        }

                        if (geojson.features.length > 1) {
                            linestring.geometry.coordinates =
                                geojson.features.map(
                                    (point) => point.geometry.coordinates
                                );

                            geojson.features.push(linestring);

                            // Populate the distanceContainer with total distance
                            const value = document.createElement('pre');
                            const distance = turf.length(linestring);
                            value.textContent = `Total distance: ${distance.toLocaleString()}km`;
                            distanceContainer.appendChild(value);
                        }

                        map.getSource('geojson').setData(geojson);
                    } else {
                        const features = map.queryRenderedFeatures(e.point, {
                            layers: ['alhambra-fills', 'alhambra-lines']
                        });

                        if (features.length > 0) {
                            let outputDiv = document.getElementById('output');
                            const selectedPolygon = features[0];
                            const name = selectedPolygon.properties.name;
                            outputDiv.innerHTML = name;
                        } else {
                            let outputDiv = document.getElementById('output');
                            outputDiv.innerHTML = 'None';
                        }
                    }
                });
            });

            map.on('mousemove', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['measure-points']
                });
                // Change the cursor to a pointer when hovering over a point on the map.
                // Otherwise cursor is a crosshair.
                map.getCanvas().style.cursor = features.length
                    ? 'pointer'
                    : 'crosshair';
            });

            document
                .querySelector('#btn-church')
                .addEventListener('click', () => {
                    map.flyTo({
                        center: [-118.146332, 34.063521],
                        zoom: 17
                    });
                });

            document.querySelector('#btn-run').addEventListener('click', () => {
                map.flyTo({
                    center: [-118.146125, 34.066507],
                    zoom: 17
                });
            });

            document
                .querySelector('#btn-school')
                .addEventListener('click', () => {
                    map.flyTo({
                        center: [-118.151082, 34.070773],
                        zoom: 17
                    });
                });

            document
                .querySelector('#btn-ruler-on')
                .addEventListener('click', () => {
                    ruler = true;
                    let outputDiv = document.getElementById('output');
                    outputDiv.innerHTML = 'Ruler On';
                });

            document
                .querySelector('#btn-ruler-off')
                .addEventListener('click', () => {
                    ruler = false;
                    let outputDiv = document.getElementById('output');
                    outputDiv.innerHTML = 'Ruler Off';
                });
            // The following values can be changed to control rotation speed:

            // At low zooms, complete a revolution every two minutes.
            const secondsPerRevolution = 120;
            // Above zoom level 5, do not rotate.
            const maxSpinZoom = 5;
            // Rotate at intermediate speeds between zoom levels 3 and 5.
            const slowSpinZoom = 3;

            let userInteracting = false;
            let spinEnabled = true;

            function spinGlobe() {
                const zoom = map.getZoom();
                if (spinEnabled && !userInteracting && zoom < maxSpinZoom) {
                    let distancePerSecond = 360 / secondsPerRevolution;
                    if (zoom > slowSpinZoom) {
                        // Slow spinning at higher zooms
                        const zoomDif =
                            (maxSpinZoom - zoom) / (maxSpinZoom - slowSpinZoom);
                        distancePerSecond *= zoomDif;
                    }
                    const center = map.getCenter();
                    center.lng -= distancePerSecond;
                    // Smoothly animate the map over one second.
                    // When this animation is complete, it calls a 'moveend' event.
                    map.easeTo({ center, duration: 1000, easing: (n) => n });
                }
            }

            // Pause spinning on interaction
            map.on('mousedown', () => {
                userInteracting = true;
            });

            // Restart spinning the globe when interaction is complete
            map.on('mouseup', () => {
                userInteracting = false;
                spinGlobe();
            });

            // These events account for cases where the mouse has moved
            // off the map, so 'mouseup' will not be fired.
            map.on('dragend', () => {
                userInteracting = false;
                spinGlobe();
            });
            map.on('pitchend', () => {
                userInteracting = false;
                spinGlobe();
            });
            map.on('rotateend', () => {
                userInteracting = false;
                spinGlobe();
            });

            // When animation is complete, start spinning if there is no ongoing interaction
            map.on('moveend', () => {
                spinGlobe();
            });

            document
                .getElementById('btn-spin')
                .addEventListener('click', (e) => {
                    spinEnabled = !spinEnabled;
                    if (spinEnabled) {
                        spinGlobe();
                        e.target.innerHTML = 'Pause rotation';
                    } else {
                        map.stop(); // Immediately end ongoing animation
                        e.target.innerHTML = 'Start rotation';
                    }
                });

            spinGlobe();
        </script>
    </body>
</html>
